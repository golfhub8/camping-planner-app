# The Camping Planner

## Overview
The Camping Planner is a full-stack web application designed to help camping families organize outdoor adventures. It provides secure user authentication, user-owned data, and robust modules for managing recipes, grocery lists, and camping trips. Key capabilities include creating and searching recipes, generating categorized shopping lists from selected recipes or entire trip meal plans, and comprehensive trip management with collaboration and cost tracking. The project aims to provide a seamless planning experience for outdoor enthusiasts, with a Pro Membership offering additional features like printable planners and games. The application is a single-page application with a REST API, PostgreSQL storage, and session-based authentication.

## User Preferences
Preferred communication style: Simple, everyday language.

## System Architecture

### UI/UX
The frontend is a React 18 application with TypeScript, Vite, and Wouter for routing. UI is built with Shadcn/ui (New York style) on Radix UI primitives, styled with Tailwind CSS, featuring a custom teal-centric color palette and modern typography. The design emphasizes a clean, outdoor aesthetic, responsiveness, and user-friendly interaction. A persistent Navbar provides navigation (Trips, Recipes, Grocery, Printables) and account management. The navbar dynamically displays a "Go Pro" button for free users or a "Pro Member" badge (linking to /account) for Pro members, updating immediately after subscription changes via React Query cache invalidation. The default route redirects to "/trips" for authenticated users.

### Technical Implementation
The backend is an Express.js application with TypeScript, providing a REST API. Authentication is integrated with Replit Auth via OpenID Connect, using session-based authentication and a PostgreSQL session store. Most API routes are protected by `isAuthenticated` middleware, ensuring user ownership for all data access. Zod is used for schema validation on all request and response payloads. The `useLogout` hook ensures a secure client-side and server-side logout flow by clearing the React Query cache and destroying sessions. Free tier usage limits (5 trips, 5 shared grocery lists) are enforced via counters in the `users` table and middleware checks, with Pro users bypassing these limits. Trip creation includes smart retry logic with exponential backoff for network and server errors. The "Trip Assistant" provides keyword-aware suggestions for campgrounds, meal plans, packing tips, and real hiking trail recommendations from the National Park Service API. Geographic detection automatically skips NPS trail searches for non-US locations (e.g., Canada, Europe) and displays a helpful message explaining the US-only limitation, preparing for future AllTrails API integration for international coverage. Graceful degradation ensures the feature works even if the NPS API is unavailable.

### Feature Specifications
- **Recipe Management:** CRUD operations on user-owned recipes, including the ability to save external WordPress recipes from TheCampingPlanner.com to personal collections with full instructions, images, and source attribution. Server-side recipe parser with comprehensive multi-tier extraction: (1) JSON-LD structured data, (2) TheCampingPlanner.com-specific "Ingredients Checklist" table extraction supporting both heading tags (`<h2>/<h3>/<h4>`) and bold paragraph labels (`<p><strong>`), formatting ingredients as `name — amount — notes` with em dashes, handling checkbox and non-checkbox table formats while skipping headers, (3) TheCampingPlanner.com-specific instruction extraction combining "Home Prep Before the Trip" + "Cooking at Camp" sections into unified step array with numeric prefix stripping, (4) WordPress Recipe Maker (WPRM) plugin selectors for ingredients checklist (`.wprm-recipe-ingredient` with structured amount/unit/name/notes fields) and instruction steps (`.wprm-recipe-instruction-text`), (5) Tasty Recipes plugin support, and (6) generic heading-based HTML scraping fallback with Gutenberg block support. Parser executes site-specific extractors first to prevent capturing random content, then falls back to generic methods. Strict validation requires both ingredients and steps (stored as string arrays). SaveRecipeModal displays parsed data in standard textarea styling and only shows success when extraction is complete. Seamless recipe creation workflow: "Add Meal → Create a Recipe" deep-links from trip detail to /recipes?createNew=true&addToTrip={tripId}, auto-expanding the recipe form and auto-adding newly created recipes to the originating trip with proper cache invalidation, error handling, and URL cleanup. **Recipe Sharing:** Token-based public recipe sharing with collision-protected token generation, link regeneration for revocation, and sanitized public viewing (no userId/shareToken exposure). Share dialog auto-generates links with one-click copy and allows regeneration to revoke old links. Public shared recipe page (/recipes/shared/:token) displays full recipe details with ability to save to personal collection. Prevents users from saving their own recipes. Recipe owners can manage share tokens via POST /api/recipes/:id/share with optional ?regenerate=true parameter.
- **Grocery List Generation & Persistence:** Dynamic grocery list generation from selected recipes or entire trip meal plans, with automatic database persistence to token-based URLs (`/grocery/list/:token`). Lists persist across sessions, survive page refreshes, and count toward free tier limits (5 lists max for free users). Features multi-meal ingredient aggregation via `getTripMeals()` for correct recipe ID extraction, deduplication, pantry item preservation, and robust error handling with retry UI. Auto-save resets `isSaving` state before navigation to prevent infinite loading. Duplicate save prevention ensures one save per sessionStorage payload, with graceful error recovery for paywall and network failures.
- **Trip Management:** Comprehensive trip creation, collaboration, cost tracking, and meal planning. Includes quick trip creation flow with auto-filled defaults. Grocery list generation from trips correctly fetches meal recipes via storage layer. AI Trip Planner placeholder visible on Trips page for future AI-powered trip generation feature (currently shows "coming soon" message).
- **Recipe-to-Trip Integration:** Query parameter-based deep-linking enables seamless "create recipe and add to trip" workflow. TripDetail's "Create a Recipe" button navigates to /recipes?createNew=true&addToTrip={tripId}, RecipeForm auto-expands via useEffect detecting createNew param, and Home.tsx onSuccess handler reads window.location.search (not Wouter location) to reliably capture addToTrip param for auto-adding newly created recipes to trips via POST /api/trips/{tripId}/meals.
- **Weather Forecasting:** Client-side real-time weather forecasts from Open-Meteo API for trips with stored coordinates, captured via Mapbox Geocoding.
- **Account & Subscription:** Account page for plan and subscription management, displaying free/trial/pro status, usage statistics, and enabling Stripe billing portal access. Manual subscription sync endpoint enables immediate Pro status updates after checkout completion.
- **Sharing:** Token-based public sharing for both recipes and grocery lists. Recipe sharing uses unique hex tokens stored in `recipes.shareToken` column with collision protection and link regeneration for revocation. Grocery list sharing via mailto: links and shareable token URLs (/shared/:token). Public endpoints sanitize responses to prevent user data leakage.

### System Design Choices
- **Frontend State Management:** TanStack Query for state management and data fetching, incorporating optimistic updates and robust caching strategies. Secure logout flow clears client cache before OIDC redirect. The `/api/auth/user` endpoint returns an `AuthUser` type (User + isPro boolean computed from proMembershipEndDate), enabling type-safe Pro status checks throughout the frontend. Account page invalidates auth query after successful checkout to update navbar immediately.
- **Authentication:** Replit Auth for OIDC login, with session-based authentication and strict user ownership verification. Auth hook properly types user as `AuthUser | null` to handle both authenticated and unauthenticated states without runtime errors.
- **Payment Processing:** Stripe Checkout Sessions for Pro Membership, with hardened checkout flow, promotion code support, customer metadata, and comprehensive webhook handling for subscription lifecycle management. Pro access is granted for active, trialing, and past_due subscription statuses. Manual `/api/billing/sync-subscription` endpoint provides immediate subscription status synchronization as fallback to webhooks. Diagnostic endpoint `/api/billing/debug` provides sanitized subscription state and troubleshooting hints without exposing sensitive Stripe data.
- **Email System:** Comprehensive automated email system covering all subscription lifecycle events via centralized `sendEmail` helper in `emailService.ts`. Email templates include: welcome emails (trial vs. non-trial), payment receipts, renewal reminders (7 days before), payment failure notifications, trial start notifications, trial ending warnings (3 days before), and cancellation confirmations. Modular webhook handler in `server/webhooks/stripeWebhook.ts` processes 7 critical Stripe events (checkout.session.completed, invoice.payment_succeeded, invoice.payment_failed, invoice.upcoming, customer.subscription.trial_will_end, customer.subscription.updated, customer.subscription.deleted) with idempotent processing, safe email dispatch (prevents webhook failures when SMTP unavailable), metadata backfill for user resolution, and automatic database synchronization. Enhanced logging tracks all webhook events and email operations.
- **Data Layer:** PostgreSQL with Neon serverless driver, accessed via Drizzle ORM. A robust database schema enforces user ownership and supports `proMembershipEndDate`, `subscriptionStatus` (cached Stripe status), and usage counters. The `shared_grocery_lists` table stores all saved grocery lists with token-based access, optional trip association, and user ownership tracking. Drizzle-Zod integration for schema validation, `drizzle-kit` for migrations.
- **Grocery List Flow:** Multi-step wizard (GrocerySelection → confirmation → auto-save → redirect). SessionStorage passes ingredient data with trip metadata (tripId, tripName). The GroceryList component auto-saves on mount using a `saveAttempted` guard to prevent duplicates, clears sessionStorage on all exit paths (success/error), and provides retry UI for error recovery. Timer cleanup via useRef prevents memory leaks.
- **Recipe Creation Flow:** Query parameter-based navigation (/recipes?createNew=true&addToTrip={tripId}) enables deep-linking from trips to recipe creation. RecipeForm monitors URL params with useEffect to auto-expand when createNew=true is present. After successful recipe creation, Home.tsx uses window.location.search (not Wouter's location hook) to reliably read query parameters in async mutation callbacks, enabling auto-add to trips with proper error handling, success toasts, and navigation cleanup.
- **Security:** SSRF protection for recipe scraping endpoints with DNS resolution, private IP range blocking, and HTTPS enforcement for external sites. Recipe sharing endpoints sanitize public responses to exclude userId and shareToken fields. Token generation includes collision detection with retry logic (max 5 attempts). Share token regeneration API enables link revocation.
- **Printables Management:** Manifest-driven architecture using `assets/printables/manifest.ts` as the single source of truth for all PDF metadata (slug, filename, title, description, tier, paperSize, icon). TypeScript schema provides type-safe helpers (`getPrintableBySlug`, `getPrintablesByTier`, `getPrintableFilePath`) consumed by backend routes. Normalized slug-based filename convention (`{slug}-{paperSize}.pdf`) prevents naming collisions. Enhanced sync script (`scripts/sync-printables.mjs`) validates manifest entries against filesystem, detects orphaned PDFs, removes 0-byte/stale files with `--clean`, and performs SHA-256 hash verification with `--verify`. Backend routes consume manifest and filter by file existence in synced destinations (free: `public/printables/`, Pro: `server/private/printables/`) before exposing to frontend. Adding new printables requires only manifest update + sync run, eliminating manual route modifications. Pre-deployment validation via sync script ensures manifest integrity.

## External Dependencies
*   **Authentication:** Replit Auth (OpenID Connect).
*   **Database:** PostgreSQL (via Neon serverless driver).
*   **ORM:** Drizzle ORM and Drizzle-Kit.
*   **Payment Processing:** Stripe Checkout Sessions.
*   **WordPress Integration:** TheCampingPlanner.com (WordPress REST API for external recipes).
*   **Weather API:** Open-Meteo free weather API.
*   **Geocoding API:** Mapbox Geocoding API.
*   **Hiking Trails:** National Park Service API for real hiking trail recommendations in Trip Assistant.
*   **Fonts:** Google Fonts (Architects Daughter, DM Sans, Fira Code, Geist Mono).
*   **Icons:** Lucide React.